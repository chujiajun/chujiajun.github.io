---
layout:     post
title:      蓝桥杯省模拟赛题解
subtitle:   随便写写
date:       2020-04-16
author:     iridescent
header-img: img/post-web.jpg
catalog: true
tags:
    - 蓝桥杯
    - 省赛
    - WIT
    - c++
---

# 填空题

#### 1、

　　将LANQIAO中的字母重新排列，可以得到不同的单词，如LANQIAO、AAILNOQ等，注意这7个字母都要被用上，单词不一定有具体的英文意义。

　　请问，总共能排列如多少个不同的单词。

> 7!/2=2520

<br>

#### 2、

　　在计算机存储中，12.5MB是多少字节？

> 12.5\*1024\*1024=13107200

<br>

#### 3、

　　由1对括号，可以组成一种合法括号序列：()。

　　由2对括号，可以组成两种合法括号序列：()()、(())。

　　由4对括号组成的合法括号序列一共有多少种？

> (((()))) 1
>
> ((()())) 2
>
> ((())()) 3
>
> ((()))() 4
>
> (()(())) 5
>
> (()()()) 6
>
> (()())() 7
>
> (())(()) 8
>
> (())()() 9
>
> ()((())) 10
>
> ()(()()) 11
>
> ()(())() 12
>
> ()()(()) 13
>
> ()()()() 14

<br>

#### 4、

　　一个包含有2019个结点的无向连通图，最少包含多少条边？

> 2018

<br>


## 编程题

#### 5、反倍数

**问题描述**

　　给定三个整数 a, b, c，如果一个整数既不是 a 的整数倍也不是 b 的整数倍还不是 c 的整数倍，则这个数称为反倍数。

　　请问在 1 至 n 中有多少个反倍数。

**输入格式**

　　输入的第一行包含一个整数 n。

　　第二行包含三个整数 a, b, c，相邻两个数之间用一个空格分隔。

**输出格式**

　　输出一行包含一个整数，表示答案。

**样例输入**

30

2 3 6

**样例输出**

10

**样例说明**

　　以下这些数满足要求：1, 5, 7, 11, 13, 17, 19, 23, 25, 29。

**评测用例规模与约定**

　　对于 40% 的评测用例，1 <= n <= 10000。

　　对于 80% 的评测用例，1 <= n <= 100000。

　　对于所有评测用例，1 <= n <= 1000000，1 <= a <= n，1 <= b <= n，1 <= c <= n。

> 略
>

```c++
#include<iostream>
using namespace std;

int main()
{
	int n,a,b,c;
	cin>>n;
	cin>>a>>b>>c;
	int ans=0;
	for (int i=1;i<=n;i++)
	{
		if (i%a!=0 && i%b!=0 && i%c!=0)
			ans++;
	}
	cout<<ans<<endl;
    return 0;
}
```

<br>


#### 6、凯撒密码

**问题描述**

　　给定一个单词，请使用凯撒密码将这个单词加密。

　　凯撒密码是一种替换加密的技术，单词中的所有字母都在字母表上向后偏移3位后被替换成密文。即a变为d，b变为e，...，w变为z，x变为a，y变为b，z变为c。

　　例如，lanqiao会变成odqtldr。

**输入格式**

　　输入一行，包含一个单词，单词中只包含小写英文字母。

**输出格式**

　　输出一行，表示加密后的密文。

**样例输入**

lanqiao

**样例输出**

odqtldr

**评测用例规模与约定**

　　对于所有评测用例，单词中的字母个数不超过100。

> 略
>

```c++
#include<iostream>
using namespace std;

int main()
{
	string s;
	cin>>s;
	for (int i=0;i<s.length();i++)
	{
		s[i]='a'+(s[i]-'a'+3)%26;
	}
	cout<<s<<endl;
    return 0;
}
```

<br>


#### 7、螺旋矩阵

**问题描述**

　　对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。

　　例如，一个 4 行 5 列的螺旋矩阵如下：

　　1 2 3 4 5

　　14 15 16 17 6

　　13 20 19 18 7

　　12 11 10 9 8

**输入格式**

　　输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。

　　第二行包含两个整数 r, c，表示要求的行号和列号。

**输出格式**

　　输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。

**样例输入**

4 5

2 2

**样例输出**

15

**评测用例规模与约定**

　　对于 30% 的评测用例，2 <= n, m <= 20。

　　对于 70% 的评测用例，2 <= n, m <= 100。

　　对于所有评测用例，2 <= n, m <= 1000，1 <= r <= n，1 <= c <= m。

> 按要求模拟即可
>

```c++
#include<bits/stdc++.h>
using namespace std;

int a[1005][1005];
	
int main()
{
	int n,m,r,c,i=1,j=0,t=0;
	memset(a,0,sizeof(a));
	cin>>n>>m;
	cin>>r>>c;
	while(t<n*m)
	{
		while (j<m && a[i][j+1]==0)
		{
			j++;
			t++;
			a[i][j]=t;
		}
		while (i<n && a[i+1][j]==0)
		{
			i++;
			t++;
			a[i][j]=t;
		}
		while (j>1 && a[i][j-1]==0)
		{
			j--;
			t++;
			a[i][j]=t;
		}
		while (i>1 && a[i-1][j]==0)
		{
			i--;
			t++;
			a[i][j]=t;
		}
	}
	cout<<a[r][c]<<endl;
    return 0;
}
```

<br>


#### 8、摆动序列

**问题描述**

　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]<a[2i-1], a[2i+1]>a[2i]。

　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。

**输入格式**

　　输入一行包含两个整数 m，n。

**输出格式**

　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。

**样例输入**

3 4

**样例输出**

14

**样例说明**

　　以下是符合要求的摆动序列：

　　2 1 2

　　2 1 3

　　2 1 4

　　3 1 2

　　3 1 3

　　3 1 4

　　3 2 3

　　3 2 4

　　4 1 2

　　4 1 3

　　4 1 4

　　4 2 3

　　4 2 4

　　4 3 4

**评测用例规模与约定**

　　对于 20% 的评测用例，1 <= n, m <= 5；

　　对于 50% 的评测用例，1 <= n, m <= 10；

　　对于 80% 的评测用例，1 <= n, m <= 100；

　　对于所有评测用例，1 <= n, m <= 1000。

> dp
>
> 第一行中，令 `d[1][j]`为：第1个数选择大于等于 j 的数的方案总数， 初始化 ` dp[1][j] = n - j + 1 `
>
> 从第二行开始：
>
> 　奇数行中，令`d[i][j]`为：第i个数选择大于等于j的数时的方案总数。
>
> 　偶数行中，令`d[i][j]`为：第i个数选择小于等于j的数时的方案总数。
>
> 则奇数行 `dp[i][j] = (dp[i-1][j-1] + dp[i][j+1]) % 10000` 
>
> 偶数行 `dp[i][j] = (dp[i-1][j+1] + dp[i][j-1]) % 10000`
>
> 若总长度为奇数，结果为`dp[m][1]` ；若为偶数，结果为`dp[m][n]` 

```c++
#include<bits/stdc++.h>
using namespace std;

int dp[1005][1005];

int main() 
{
    int m,n;
    cin>>m>>n;
    for (int i=1;i<=n;i++)
        dp[1][i]=n-i+1;
    for (int i=2;i<=m;i++)
        if (i%2)
            for (int j=n;j>=1;j--)
                dp[i][j]=(dp[i-1][j-1]+dp[i][j+1])%10000;
        else
            for	(int j=1;j<=n;j++)
                dp[i][j]=(dp[i-1][j+1]+dp[i][j-1])%10000;
    int ans;
    if (m%2)
    	ans=dp[m][1];
    else
    	ans=dp[m][n];
    cout<<ans<<endl;
    return 0;
}
```

<br>


#### 9、村庄通电

**问题描述**

　　2015年，全中国实现了户户通电。作为一名电力建设者，小明正在帮助一带一路上的国家通电。

　　这一次，小明要帮助 n 个村庄通电，其中 1 号村庄正好可以建立一个发电站，所发的电足够所有村庄使用。

　　现在，这 n 个村庄之间都没有电线相连，小明主要要做的是架设电线连接这些村庄，使得所有村庄都直接或间接的与发电站相通。

　　小明测量了所有村庄的位置（坐标）和高度，如果要连接两个村庄，小明需要花费两个村庄之间的坐标距离加上高度差的平方，形式化描述为坐标为 (x_1, y_1) 高度为 h_1 的村庄与坐标为 (x_2, y_2) 高度为 h_2 的村庄之间连接的费用为

　　sqrt((x_1-x_2)*(x_1-x_2)+(y_1-y_2)*(y_1-y_2))+(h_1-h_2)*(h_1-h_2)。

　　在上式中 sqrt 表示取括号内的平方根。请注意括号的位置，高度的计算方式与横纵坐标的计算方式不同。

　　由于经费有限，请帮助小明计算他至少要花费多少费用才能使这 n 个村庄都通电。

**输入格式**

　　输入的第一行包含一个整数 n ，表示村庄的数量。

　　接下来 n 行，每个三个整数 x, y, h，分别表示一个村庄的横、纵坐标和高度，其中第一个村庄可以建立发电站。

**输出格式**

　　输出一行，包含一个实数，四舍五入保留 2 位小数，表示答案。

**样例输入**

4

1 1 3

9 9 7

8 8 6

4 5 4

**样例输出**

17.41

**评测用例规模与约定**

　　对于 30% 的评测用例，1 <= n <= 10；

　　对于 60% 的评测用例，1 <= n <= 100；

　　对于所有评测用例，1 <= n <= 1000，0 <= x, y, h <= 10000。

> 最小生成树
>

```c++
#include <bits/stdc++.h>
using namespace std;

int n,m=0,t=0;
double ans;
int x[1005],y[1005],h[1005];
struct node
{
    int x,y;
	double z;
}edge[1000005];
int pre[1005];

bool cmp(node a, node b)
{
    return a.z<b.z;
}

int find(int x)
{
    if(x!=pre[x])
    {
        pre[x]=find(pre[x]);
    }
    return pre[x];
}

void merge(int x,int y,int i)
{
    int fx=find(x);
    int fy=find(y);
    if(fx!=fy)
    {
        pre[fx]=fy;
        ans+=edge[i].z;
        t++;
    }
}

int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
		cin>>x[i]>>y[i]>>h[i];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (i!=j)
			{
				double dis=sqrt(pow(abs(x[i]-x[j]),2)+pow(abs(y[i]-y[j]),2))+pow(abs(h[i]-h[j]),2);
				m++; edge[m].x=i; edge[m].y=j; edge[m].z=dis;
				m++; edge[m].x=j; edge[m].y=i; edge[m].z=dis;
			}
    for (int i=1;i<=n;i++)
    {
        pre[i]=i;
    }
    sort(edge+1,edge+m+1,cmp);
    for (int i=1;i<=m;i++)
    {
    	if (t==n-1)
    		break;
        merge(edge[i].x,edge[i].y,i);
    }
    printf("%.2f\n",ans);
    return 0;
}
```

<br>


#### 10、植树

**问题描述**

　　小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。

　　小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。

　　然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。

　　他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。

　　小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。

**输入格式**

　　输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。

　　接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。

**输出格式**

　　输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。

**样例输入**

6

1 1 2

1 4 2

1 7 2

4 1 2

4 4 2

4 7 2

**样例输出**

12

**评测用例规模与约定**

　　对于 30% 的评测用例，1 <= n <= 10；

　　对于 60% 的评测用例，1 <= n <= 20；

　　对于所有评测用例，1 <= n <= 30，0 <= x, y <= 1000，1 <= r <= 1000。

> dfs+回溯

```c++
#include<bits/stdc++.h>
using namespace std;

int x[1005],y[1005],r[1005];
double pi=acos(-1);
bool vis[1005];
int n,ans=0;

bool f(int i)
{
	for (int j=0;j<n;j++)
	{
		if (i!=j && vis[j])
		{
			int dis=pow(abs(x[i]-x[j]),2)+pow(abs(y[i]-y[j]),2);
			if (dis<pow(abs(r[i]+r[j]),2)) 
				return false;
		}
	}
	return true;
}

void dfs(int step, int sum)
{
	if(step==n)
	{
		ans=max(ans,sum);
		return;
	}
	for(int i=0;i<n;i++)
	{
		if(!vis[i])
		{
			int t=r[i];
			if (!f(i)) 
				r[i] = 0;
			vis[i]=true;
			dfs(step+1,sum+r[i]*r[i]);
			vis[i]=false;
			r[i]=t;
		}
	}
}

int main()
{
	cin>>n;
	for (int i=0;i<n;i++)
		cin>>x[i]>>y[i]>>r[i];
	dfs(0,0);
	cout<<ans<<endl;
	return 0;
}
```

<br>